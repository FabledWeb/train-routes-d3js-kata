<!DOCTYPE html>
<html>
  <head> 
    <meta charset="utf-8">
    <style>
    .node {
      stroke: #ddd;
      stroke-width: 1.5px;
    }
    .node, .text, .link {
      -webkit-transition: all 0.3s; /* Safari */
      transition: all 0.3s;
    }
    .init {
      fill-opacity: 0.7;
      stroke-opacity: 0.7;
    }
    .selected, .start, .end {
      fill-opacity: 1;
      stroke-opacity: 1;
    }
    .not-selected {
      fill-opacity: 0.3;
      stroke-opacity: 0.3;
    }
    .node.start {
      stroke: rgba(25, 250, 100, 0.75);
      stroke-width: 5px;
    }
    .node.end {
      stroke: rgba(250, 25, 100, 0.75);
      stroke-width: 5px;
    }
    .link {
      stroke-width: 5px;
    }
    .link.selected {
      stroke-width: 7px;
    }
    .link.not-selected {
      stroke-width: 3px;
    }
    #canvas {
      height: 100%;
      width: 100%;
      top: 0;
      left: 0;
      position: absolute;
    }
    </style>
  </head> 
  <body>
    <svg id="canvas"></svg>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.0/lodash.min.js"><!-- using for easier data mapping --> </script>
    <script>
/**
 * Basic priority queue implementation. If a better priority queue is wanted/needed,
 * this code works with the implementation in google's closure library (https://code.google.com/p/closure-library/).
 * Use goog.require('goog.structs.PriorityQueue'); and new goog.structs.PriorityQueue()
 */
function PriorityQueue () {
  this._nodes = [];

  this.enqueue = function (priority, key) {
    this._nodes.push({key: key, priority: priority });
    this.sort();
  }
  this.dequeue = function () {
    return this._nodes.shift().key;
  }
  this.sort = function () {
    this._nodes.sort(function (a, b) {
      return a.priority - b.priority;
    });
  }
  this.isEmpty = function () {
    return !this._nodes.length;
  }
}

/**
 * Pathfinding starts here
 */
function Graph(){
  var INFINITY = 1/0;
  this.vertices = {};

  this.addVertex = function(name, edges){
    this.vertices[name] = edges;
  }

  this.shortestPath = function (start, finish) {
    var nodes = new PriorityQueue(),
        distances = {},
        previous = {},
        path = [],
        smallest, vertex, neighbor, alt;

    for(vertex in this.vertices) {
      if(vertex === start) {
        distances[vertex] = 0;
        nodes.enqueue(0, vertex);
      }
      else {
        distances[vertex] = INFINITY;
        nodes.enqueue(INFINITY, vertex);
      }

      previous[vertex] = null;
    }

    while(!nodes.isEmpty()) {
      smallest = nodes.dequeue();

      if(smallest === finish) {
        path;

        while(previous[smallest]) {
          path.push(smallest);
          smallest = previous[smallest];
        }

        break;
      }

      if(!smallest || distances[smallest] === INFINITY){
        continue;
      }

      for(neighbor in this.vertices[smallest]) {
        alt = distances[smallest] + this.vertices[smallest][neighbor];

        if(alt < distances[neighbor]) {
          distances[neighbor] = alt;
          previous[neighbor] = smallest;

          nodes.enqueue(alt, neighbor);
        }
      }
    }

    return path;
  }
}
    </script>
    <script>
      var dijkstrasGraph = new Graph();
      var transformData = function(dataString) {
        var locations = {};
        var data = d3.csv.parse(dataString, function(d) {
          //convert distance from a string to a number
          d.distance = +d.distance;
          locations[d.source] = locations[d.source] || {destinations:{}};
          locations[d.source].destinations[d.destination] = d.distance;
          locations[d.destination] = locations[d.destination] || {destinations:{}};
          return d;
        });
        var nodes = _.map(Object.keys(locations), function(source,index) {
          locations[source].index = index;
          return {
            index: index,
            name: source,
            destinations: locations[source].destinations
          };
        });
        var edges = [];
        _.forEach(nodes, function(source,index) {
            dijkstrasGraph.addVertex(source.name, source.destinations);
          _.forIn(source.destinations, function(distance,destName) {
            edges.push({
              source: source.index,
              target: locations[destName].index
            });
          });
        });
        
        return {
          edges: edges,
          nodes: nodes
        };
      };

      var addArrows = function(x,label,canvas) {
        //add directional arrows to lines
        canvas.selectAll('marker_'+label)
          .data(graph.edges)
          .enter().append('marker')
            .attr('id', function(d,i){ return 'marker_'+label + i})
            .attr('markerHeight', 5)
            .attr('markerWidth', 6)
            .attr('markerUnits', 'strokeWidth')
            .attr('orient', 'auto')
            .attr('refX', x)
            .attr('refY', 5)
            .attr('viewBox', '0 0 10 10')
            .append('path')
              .attr('fill-opacity', 0.6)
              .attr('d', "M 0 0 L 10 5 L 0 10 z")
              .attr('fill', function(d,i) { return color(i); });
      };

      var graph = transformData(
        "source,destination,distance\n"+
        "Frolia,Hailea,9\n"+
        "Hailea,Hanalei,5\n"+
        "Hanalei,Maeulia,6\n"+
        "Hauauai,Lainea,8\n"+
        "Kaleola,Maeulia,7\n"+
        "Lainea,Hailea,5\n"+
        "Lakua,Hauauai,3\n"+
        "Maeulia,Hailea,12\n"+
        "Paukaa,Hauauai,6\n"+
        "Poipu,Paukaa,9\n"+
        "Hailea,Waimea,4\n"+
        "Waimea,Lakua,9\n"+
        "Lakua,Poipu,7\n"+
        "Waimea,Kaleola,4\n"+
        "Maeulia,Paukaa,14\n"+
        "Hailea,Lainea,8"
      );
      var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      var routeScale = Math.min(width,height)/20;
      var color = d3.scale.category20();
      var svg = d3.select("#canvas");

      var force = d3.layout.force()
        .charge(-2000)
        .linkDistance(function(d) {
          return d.source.destinations[d.target.name]*routeScale;
        })
        .size([width, height])
        .nodes(graph.nodes)
        .links(graph.edges)
        .start();
      
      //add arrows to the start and end of a line
      addArrows(-22,'start',svg);
      addArrows(20,'end',svg);

      var link = svg.selectAll(".link")
        .data(graph.edges)
        .enter().append("line")
        .attr("class", "link init")
        .attr('marker-start', function(d,i) { return 'url(#marker_start' + i + ')' })
        .attr('marker-end', function(d,i) { return 'url(#marker_end' + i + ')' })
        .attr("stroke", function(d,i) { return color(i); });

      var selected = {
        start: { elem: null, data: null },
        end: { elem: null, data: null }
      };

      var routeMap = {};
      var highlightRoute = function(route) {
        routeMap = {};
        for(var i=0; i<route.length-1; i++) {
          routeMap[route[i]] = route[i+1];
        }
        node.attr("class", function(d,i) {
          var className = this.getAttribute('class');
          if(d.name === selected.start.data.name) {
            className = 'node start';
          }
          else if(d.name === selected.end.data.name) {
            className = 'node end';
          }
          else {
            className = routeMap[d.name] ? 'node selected' : 'node not-selected';
          }
          return className;
        });
        text.attr("class", function(d,i) {
          var className = this.getAttribute('class');
          if(d.name === selected.start.data.name) {
            className = 'text start';
          }
          else if(d.name === selected.end.data.name) {
            className = 'text end';
          }
          else {
            className = routeMap[d.name] ? 'text selected' : 'text not-selected';
          }
          return className;
        });
        link.attr("class", function(d,i) {
          return routeMap[d.source.name] === d.target.name ? 'link selected' : 'link not-selected';
        });
      };

      var nodeClick = function(d,i) {
        //reset selection display
        d3.select(selected.start.elem).classed("start", false);
        d3.select(selected.end.elem).classed("end", false);

        //figure out the last 2 nodes selected
        if(!selected.start.elem) { //choosing a start for the first time
          selected.start = {
            elem: this,
            data: d
          };
        }
        else { //selecting a destination
          if(selected.end.elem) { //changing the destination -- make the previous destination the start
            selected.start = selected.end;
          }
          selected.end = {
            elem: this,
            data: d
          };
        }
        //set the selection display
        d3.select(selected.start.elem).classed("start", true);
        d3.select(selected.end.elem).classed("end", true);

        if(selected.end.elem) {
          var route = dijkstrasGraph.shortestPath(selected.start.data.name, selected.end.data.name).concat([selected.start.data.name]).reverse();
          highlightRoute(route);
        }
      };
      var node = svg.selectAll(".node")
        .data(graph.nodes)
        .enter().append("circle")
        .attr("class", "node init")
        .attr("r", 10)
        .on("click", nodeClick);

      var text = svg.selectAll(".text")
        .data(graph.nodes)
        .enter().append("text")
        .attr('x',function(d) { return d.x; })
        .attr('y',function(d) { return d.y; })
        .attr('class', 'text init')
        .text(function(d) { return d.name; });

      link.append("title")
        .text(function(d) { return d.source.destinations[d.target.name] + 'km to '+d.target.name; });

      force.on("tick", function() {
        link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });

        text.attr("x", function(d) { return d.x - 30; })
            .attr("y", function(d) { return d.y - 20; });
      });

    </script>
  </body>
</html>
